# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# dev-deploy.yml â€” Build and deploy all microservices to your local
# Kind cluster via kindling.
#
# This workflow runs on your SELF-HOSTED runner (created by the
# GithubActionRunnerPool CR). It uses Kaniko to build four container
# images (three Go services + a React dashboard) and pushes them to
# the in-cluster registry at registry:5000. It then applies four
# DevStagingEnvironment CRs â€” the kindling operator provisions
# Postgres, MongoDB, and Redis automatically.
#
# No Docker daemon required â€” Kaniko builds in userspace pods.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
name: Microservices Deploy

on:
  push:
    branches: [main]
    paths:
      - "**"
      - ".github/workflows/dev-deploy.yml"
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: [self-hosted, "${{ github.actor }}"]

    env:
      TAG: "${{ github.actor }}-${{ github.sha }}"
      REGISTRY: "registry:5000"

    steps:
      # â”€â”€ 0. Clean shared /builds dir from any previous run â”€â”€â”€â”€â”€â”€â”€â”€
      #
      # The /builds emptyDir persists across workflow runs (same pod).
      # Stale .done / .apply-done / .kubectl-done files from a previous
      # run would cause every wait-loop to exit immediately.
      #
      - name: Clean builds directory
        run: |
          echo "ğŸ§¹ Cleaning stale signal files from /builds..."
          rm -f /builds/*.done /builds/*.request /builds/*.processing \
                /builds/*.apply /builds/*.apply-done /builds/*.apply-log \
                /builds/*.apply-exitcode /builds/*.kubectl \
                /builds/*.kubectl-done /builds/*.kubectl-log \
                /builds/*.kubectl-exitcode /builds/*.exitcode \
                /builds/*.log /builds/*.dest /builds/*.tar.gz \
                /builds/*.yaml /builds/*.sh /builds/portfwd-ready \
                /builds/portfwd-stop
          echo "âœ… /builds is clean"

      # â”€â”€ 1. Checkout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout code
        uses: actions/checkout@v4

      # â”€â”€ 2. Build all service images via the build-agent sidecar â”€â”€â”€â”€â”€â”€
      #
      # The runner pod has a build-agent sidecar with kubectl that watches
      # /builds for requests. For each service we:
      #   1. tar up the build context â†’ /builds/<svc>.tar.gz
      #   2. write the destination   â†’ /builds/<svc>.dest
      #   3. touch the trigger       â†’ /builds/<svc>.request
      #   4. wait for               â†’ /builds/<svc>.done
      # The sidecar pipes the tarball into a one-shot Kaniko pod.
      #
      - name: Build & push gateway image
        run: |
          tar -czf /builds/gateway.tar.gz -C gateway/ .
          echo "$REGISTRY/ms-gateway:$TAG" > /builds/gateway.dest
          touch /builds/gateway.request
          echo "â³ Waiting for gateway build..."
          while [ ! -f /builds/gateway.done ]; do sleep 2; done
          EXIT_CODE=$(cat /builds/gateway.exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Gateway build failed:"; cat /builds/gateway.log; exit 1
          fi
          echo "âœ… Built & pushed ms-gateway:$TAG"

      - name: Build & push orders image
        run: |
          tar -czf /builds/orders.tar.gz -C orders/ .
          echo "$REGISTRY/ms-orders:$TAG" > /builds/orders.dest
          touch /builds/orders.request
          echo "â³ Waiting for orders build..."
          while [ ! -f /builds/orders.done ]; do sleep 2; done
          EXIT_CODE=$(cat /builds/orders.exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Orders build failed:"; cat /builds/orders.log; exit 1
          fi
          echo "âœ… Built & pushed ms-orders:$TAG"

      - name: Build & push inventory image
        run: |
          tar -czf /builds/inventory.tar.gz -C inventory/ .
          echo "$REGISTRY/ms-inventory:$TAG" > /builds/inventory.dest
          touch /builds/inventory.request
          echo "â³ Waiting for inventory build..."
          while [ ! -f /builds/inventory.done ]; do sleep 2; done
          EXIT_CODE=$(cat /builds/inventory.exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Inventory build failed:"; cat /builds/inventory.log; exit 1
          fi
          echo "âœ… Built & pushed ms-inventory:$TAG"

      - name: Build & push UI image
        run: |
          tar -czf /builds/ui.tar.gz -C ui/ .
          echo "$REGISTRY/ms-ui:$TAG" > /builds/ui.dest
          touch /builds/ui.request
          echo "â³ Waiting for UI build..."
          while [ ! -f /builds/ui.done ]; do sleep 2; done
          EXIT_CODE=$(cat /builds/ui.exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ UI build failed:"; cat /builds/ui.log; exit 1
          fi
          echo "âœ… Built & pushed ms-ui:$TAG"

      # â”€â”€ 3. Deploy Orders Service (Postgres + Redis) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      #
      # Each deploy step writes YAML to /builds/<name>.yaml and touches
      # /builds/<name>.apply â€” the build-agent sidecar runs kubectl apply.
      # Using unquoted heredocs so bash expands $REGISTRY, $TAG, etc.
      #
      - name: Deploy orders service
        run: |
          cat > /builds/orders.yaml <<EOF
          apiVersion: apps.example.com/v1alpha1
          kind: DevStagingEnvironment
          metadata:
            name: ${{ github.actor }}-orders
            labels:
              app.kubernetes.io/part-of: microservices-demo
              app.kubernetes.io/component: orders
              apps.example.com/github-username: ${{ github.actor }}
          spec:
            deployment:
              image: $REGISTRY/ms-orders:$TAG
              replicas: 1
              port: 8081
              healthCheck:
                path: /healthz
            service:
              port: 8081
              type: ClusterIP
            dependencies:
              - type: postgres
                version: "16"
              - type: redis
          EOF
          touch /builds/orders.apply
          while [ ! -f /builds/orders.apply-done ]; do sleep 1; done
          EXIT_CODE=$(cat /builds/orders.apply-exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Orders apply failed:"; cat /builds/orders.apply-log; exit 1
          fi
          echo "âœ… Orders DevStagingEnvironment applied"

      # â”€â”€ 4. Deploy Inventory Service (MongoDB + shared Redis) â”€â”€â”€â”€â”€
      - name: Deploy inventory service
        run: |
          cat > /builds/inventory.yaml <<EOF
          apiVersion: apps.example.com/v1alpha1
          kind: DevStagingEnvironment
          metadata:
            name: ${{ github.actor }}-inventory
            labels:
              app.kubernetes.io/part-of: microservices-demo
              app.kubernetes.io/component: inventory
              apps.example.com/github-username: ${{ github.actor }}
          spec:
            deployment:
              image: $REGISTRY/ms-inventory:$TAG
              replicas: 1
              port: 8082
              env:
                - name: REDIS_URL
                  value: "redis://${{ github.actor }}-orders-redis:6379/0"
              healthCheck:
                path: /healthz
            service:
              port: 8082
              type: ClusterIP
            dependencies:
              - type: mongodb
          EOF
          touch /builds/inventory.apply
          while [ ! -f /builds/inventory.apply-done ]; do sleep 1; done
          EXIT_CODE=$(cat /builds/inventory.apply-exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Inventory apply failed:"; cat /builds/inventory.apply-log; exit 1
          fi
          echo "âœ… Inventory DevStagingEnvironment applied"

      # â”€â”€ 5. Deploy Gateway â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy gateway
        run: |
          cat > /builds/gateway-deploy.yaml <<EOF
          apiVersion: apps.example.com/v1alpha1
          kind: DevStagingEnvironment
          metadata:
            name: ${{ github.actor }}-gateway
            labels:
              app.kubernetes.io/part-of: microservices-demo
              app.kubernetes.io/component: gateway
              apps.example.com/github-username: ${{ github.actor }}
          spec:
            deployment:
              image: $REGISTRY/ms-gateway:$TAG
              replicas: 1
              port: 8080
              env:
                - name: ORDERS_SERVICE_URL
                  value: "http://${{ github.actor }}-orders:8081"
                - name: INVENTORY_SERVICE_URL
                  value: "http://${{ github.actor }}-inventory:8082"
              healthCheck:
                path: /healthz
            service:
              port: 8080
              type: ClusterIP
          EOF
          touch /builds/gateway-deploy.apply
          while [ ! -f /builds/gateway-deploy.apply-done ]; do sleep 1; done
          EXIT_CODE=$(cat /builds/gateway-deploy.apply-exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ Gateway apply failed:"; cat /builds/gateway-deploy.apply-log; exit 1
          fi
          echo "âœ… Gateway DevStagingEnvironment applied"

      # â”€â”€ 6. Deploy UI Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy UI dashboard
        run: |
          cat > /builds/ui-deploy.yaml <<EOF
          apiVersion: apps.example.com/v1alpha1
          kind: DevStagingEnvironment
          metadata:
            name: ${{ github.actor }}-ui
            labels:
              app.kubernetes.io/part-of: microservices-demo
              app.kubernetes.io/component: ui
              apps.example.com/github-username: ${{ github.actor }}
          spec:
            deployment:
              image: $REGISTRY/ms-ui:$TAG
              replicas: 1
              port: 80
              env:
                - name: GATEWAY_URL
                  value: "http://${{ github.actor }}-gateway:8080"
              healthCheck:
                path: /
            service:
              port: 80
              type: ClusterIP
            ingress:
              enabled: true
              host: ${{ github.actor }}-ui.localhost
              ingressClassName: nginx
          EOF
          touch /builds/ui-deploy.apply
          while [ ! -f /builds/ui-deploy.apply-done ]; do sleep 1; done
          EXIT_CODE=$(cat /builds/ui-deploy.apply-exitcode)
          if [ "$EXIT_CODE" != "0" ]; then
            echo "âŒ UI apply failed:"; cat /builds/ui-deploy.apply-log; exit 1
          fi
          echo "âœ… UI DevStagingEnvironment applied"

      # â”€â”€ 7. Wait for rollouts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Wait for all deployments
        run: |
          ACTOR="${{ github.actor }}"
          cat > /builds/rollout-wait.sh <<SCRIPT
          #!/bin/bash
          for svc in orders inventory gateway ui; do
            echo "â³ Waiting for ${ACTOR}-\${svc}..."
            kubectl rollout status deployment/${ACTOR}-\${svc} \
              --timeout=120s || true
          done

          echo ""
          echo "ğŸ“¦ Pods:"
          kubectl get pods -l app.kubernetes.io/part-of=microservices-demo

          echo ""
          echo "ğŸŒ Services:"
          kubectl get svc | grep -E "${ACTOR}-(gateway|orders|inventory|ui)"

          echo ""
          echo "ğŸ¯ DevStagingEnvironments:"
          kubectl get devstagingenvironments -l app.kubernetes.io/part-of=microservices-demo
          SCRIPT
          chmod +x /builds/rollout-wait.sh
          touch /builds/rollout-wait.kubectl
          while [ ! -f /builds/rollout-wait.kubectl-done ]; do sleep 2; done
          cat /builds/rollout-wait.kubectl-log
          echo ""
          EXIT_CODE=$(cat /builds/rollout-wait.kubectl-exitcode)
          [ "$EXIT_CODE" = "0" ] || exit 1

      # â”€â”€ 8. Smoke test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Smoke test
        run: |
          cat > /builds/smoke-portfwd.sh <<SCRIPT
          #!/bin/bash
          kubectl port-forward svc/${{ github.actor }}-gateway 18080:8080 &
          PF_PID=\$!
          sleep 3
          touch /builds/portfwd-ready
          while [ ! -f /builds/portfwd-stop ]; do sleep 1; done
          kill \$PF_PID 2>/dev/null || true
          SCRIPT
          chmod +x /builds/smoke-portfwd.sh
          touch /builds/smoke-portfwd.kubectl
          while [ ! -f /builds/portfwd-ready ]; do sleep 1; done

          echo "â”€â”€ Gateway health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          curl -sf http://localhost:18080/healthz | jq . || echo "(not ready yet)"

          echo ""
          echo "â”€â”€ Aggregated status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          curl -sf http://localhost:18080/status | jq . || echo "(not available)"

          echo ""
          echo "â”€â”€ Create an order â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          curl -sf -X POST http://localhost:18080/orders \
            -H "Content-Type: application/json" \
            -d '{"product":"widget-a","quantity":2}' | jq . || echo "(failed)"

          echo ""
          echo "â”€â”€ Check inventory (stock decremented) â”€"
          sleep 2
          curl -sf http://localhost:18080/inventory | jq . || echo "(failed)"

          touch /builds/portfwd-stop
          while [ ! -f /builds/smoke-portfwd.kubectl-done ]; do sleep 1; done

          echo ""
          echo "ğŸ‰ All services deployed!"
          echo "ğŸ¨ UI dashboard: http://${{ github.actor }}-ui.localhost"
          echo "ğŸŒ Gateway API:  http://${{ github.actor }}-gateway.localhost"
          echo "ğŸ“¡ Fallback:     kubectl port-forward svc/${{ github.actor }}-gateway 8080:8080"
